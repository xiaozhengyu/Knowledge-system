# MySQL - 数据类型

---

[TOC]

## 字段类型

### 整数

TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，在满足业务需求的情况下，应该尽量使用存储空间更小的列，<u>除了节约存储空间，更能提高查询性能</u>。

| 类型      | 存储空间     |
| --------- | ------------ |
| TINYINT   | 1字节 = 8位  |
| SMALLINT  | 2字节 = 16位 |
| MEDIUMINT | 3字节 = 24位 |
| INT       | 4字节 = 32位 |
| BIGINT    | 8字节 = 64位 |

INT(11) 中的数字只是规定了交互工具显示字符的个数，<span style="border-bottom:2px dashed blue">对于存储和计算来说是没有意义的。</span>



### 浮点数

FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。<span style="border-bottom:2px dashed blue">CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。</span>

FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。

### 字符串

主要有 CHAR 和 VARCHAR 两种类型：

| CHAR                          | VARCHAR                       |
| ----------------------------- | ----------------------------- |
| <font color = red>定长</font> | <font color = red>变长</font> |
| 删除字符串尾部的空格          | 保留字符串尾部的空格          |

VARCHAR 这种变长类型能够<u>节省空间</u>，因为只需要存储必要的内容。<span style="border-bottom:2px dashed blue">但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。</span>MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。



### 日期时间

MySQL 提供了两种相似的日期时间类型: DATETIME 和 TIMESTAMP：

| DATETIME                                           | TIMESTAMP                                                    |
| -------------------------------------------------- | ------------------------------------------------------------ |
| 8字节                                              | 4字节                                                        |
| 能够保存从 1001 年到 9999 年的日期和时间，精度为秒 | 和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜(格林威治时间)以来的秒数，只能表从 1970 年 到 2038 年的日期和时间 |
| 时区无关                                           | 时区相关——也就是说一个时间戳在不同的时区所代表的具体时间是不同的 |

应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。



## 字段优化

优化策略：

-   **更小**：更小的数据类型通常更快，因为它们占用更少的磁盘、内存和CPU缓存，并且处理时需要的CPU周期也更少
-   **更易于操作**：例如，整形比字符串操作代价更低；使用内建类型而不是字符串来存储日期和时间；用整形存储IP地址等
-   **尽量避免NULL**：如果查询中包含可为NULL的列，对MySQL来说更难优化，因为可为NULL 的列使得索引、索引统计和值比较都更复杂。尽管把可为NULL的列改为NOT NULL带来的性能提升比较小，<span style="border-bottom:2px dashed blue">但如果计划在列上创建索引，就应该尽量避免设计成可为NULL的列</span>



### 字符串

#### VARCHAR 还是 CHAR ？

VARCHAR是最常见的字符串类型。<u>VARCHAR节省了存储空间，所以对性能也有帮助</u>。但是，<u>由于行是可变的，在UPDATE时可能使行变得比原来更长，这就导致需要做额外的工作</u>。如果一个行占用的空间增长，并且在页内没有更多的空间可以存储，MyISAM会将行拆成不同的片段存储；InnoDB则需要分裂页来使行可以放进页内。

<span style="border-bottom:2px dashed blue">下面这些情况使用VARCHAR是合适的：字符串的最大长度比平均长度大很多；列的更新很少，所以碎片不是问题；使用了像UTF-8这样复杂的字符集，每个字符都使用不同的字节数进行存储。</span>

当存储CHAR值时，MySQL会删除所有的末尾空格。CHAR值会根据需要采用空格进行填充以方便比较。

<span style="border-bottom:2px dashed blue">CHAR适合存储很短的字符串，或者所有值都接近同一个长度，如密码的MD5值。对于经常变更的数据，CHAR也比VARCHAR更好，因为CHAR不容易产生碎片（大小在一开始就确定下来了，后续不可能发生改变）</span>



#### VARCHAR(5) 还是 VARCHAR(200) ?

>   使用VARCHAR(5)和VARCHAR(200)存储"hello"的**空间开销是一样的**。那么使用更短的列有什么优势吗？

事实证明有很大的优势。虽然使用varchar(5)和varchar(200)存储“hello”占用的磁盘空间是一样的，但是**内存消耗不一样**。更长的列消耗的内存会更多。因为MySQL通常会分配固定大小的内存块来保存内部值。尤其是使用内存临时表进行排序或其他操作时会特别糟糕。在利用磁盘临时表进行排序时也同样糟糕。

所以最好的策略是只分配真正需要的空间。



#### BLOB 和 TEXT 

BLOB和TEXT都是为存储很大的数据而设计的数据类型，分别采用二进制和字符方式存储。

与其他类型不同，MySQL把每个BLOB和TEXT值当做一个独立的对象去处理。<mark style="background-color: #e2e9ee">当BLOB和TEXT值太大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1~4个字节存储一个指针，然后在外部存储区域存储实际的值。</mark>

<mark style="background-color: #e2e9ee">MySQL对BLOB和TEXT列进行排序与其他类型是不同的：只对每个列的最前max_sort_length个字节而不是整个字符串做排序。同样的，MySQL也不能将BLOB或TEXT列全部长度的字符串进行索引。</mark>



### 标识符（identifier）

<mark>整数类型通常是标识列的最佳选择，因为它们很快并且可以使用AUTO_INCREMENT。 如果可能，应该避免使用字符串类型作为标识列，因为它们很耗空间，并且比数字类型慢。</mark> 对于完全随机的字符串也需要多加注意，例如MD5(),SHA1()或者UUID()产生的字符串。这些函数生成的新值会任意分布在很大的空间内，这会导致INSERT以及一些SELECT语句变得很慢：

-   因为插入值会随机的写入到索引的不同位置，所以使得INSERT语句更慢。这会导致页分裂、磁盘随机访问。
-   SELECT语句会变的更慢，因为逻辑上相邻的行会分布在磁盘和内存的不同地方。
-   随机值导致缓存对所有类型的查询语句效果都很差，因为会使得缓存赖以工作的局部性原理失效。
