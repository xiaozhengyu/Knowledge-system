# MySQL - InnoDB - MVCC 多版本并发控制

参考文章：

1.   [MySQL-InnoDB-MVCC多版本并发控制](https://segmentfault.com/a/1190000012650596)

2.   [浅谈MySQL并发控制：隔离级别、锁与MVCC](https://juejin.cn/post/6844904096378404872)

3.   [MVCC ReadView介绍](https://www.cnblogs.com/jmliao/p/13204946.html)

---

## 前言

如果数据库中的事务都是串行执行的，这种方式虽然可以确保多个事务的执行不会互相影响，但会使系统出现性能瓶颈；如果事务是并发执行的，在不加以控制的前提下将引发诸多问题，如更新丢失、脏读、不可重复读、幻读、死锁等。这就需要我们在性能和安全之间做出权衡，使用合理的并发控制机制来保证并发事务的执行。

## 事务的并发场景

事务的并发场景可以归为3类：

-   **读-读**

    由于读操作并不会对记录产生任何影响，因此“读-读”场景不存在安全问题，无需额外控制。

-   **写-写**

    并发事务相继对同一记录进行更新操作时可能出现丢失更新的问题：

    1.  后一个事务发生回滚，导致前一个事务提交的更新被回滚数据覆盖，即出现**回滚覆盖**的问题，也称**第一类丢失更新**
    2.  前一个事务提交的更新被后一个事务提交的更新覆盖，即出现**提交覆盖**的问题，也称**第二类丢失更新**

-   **读-写**

    这种情况最为复杂，也最容易出现问题：

    1.  **脏读**

        |      事务1：向B账号汇款100元       |      事务2：从B账号取款200元       |
        | :--------------------------------: | :--------------------------------: |
        |                                    |                                    |
        | <font color = blue>开始事务</font> |                                    |
        |        查询A账号余额为200元        |                                    |
        |        查询B账号余额为200元        |                                    |
        |        修改A账号余额为100元        |                                    |
        |        修改B账号余额为300元        | <font color = blue>开始事务</font> |
        |                ...                 |        查询B账号余额为300元        |
        |                ...                 |        修改B账号余额为100元        |
        | <font color = red>回滚事务</font>  | <font color = blue>提交事务</font> |
        |        恢复A账号余额为200元        |                                    |
        |        恢复B账号余额为200元        |                                    |

    2.  **不可重复读**

        |      事务1：向B账号汇款100元       |        事务2：XXXXXXXXXXXX         |
        | :--------------------------------: | :--------------------------------: |
        |                                    |                                    |
        | <font color = blue>开始事务</font> |                                    |
        |        查询A账号余额为200元        |                                    |
        |        查询B账号余额为200元        |                                    |
        |        修改A账号余额为100元        |                                    |
        |        修改B账号余额为300元        | <font color = blue>开始事务</font> |
        |                ...                 |        查询B账号余额为300元        |
        |                ...                 |                ...                 |
        | <font color = red>回滚事务</font>  |                ...                 |
        |        恢复B账号余额为200元        |                ...                 |
        |        恢复A账号余额为200元        |                ...                 |
        |                                    |                ...                 |
        |                                    |        查询B账号余额为200元        |
        |                                    |                ...                 |
        |                                    | <font color = blue>提交事务</font> |

    3.  **幻读**

        |      事务1：向B账号汇款100元       |      事务2：查询B账号入款记录      |
        | :--------------------------------: | :--------------------------------: |
        |                                    |                                    |
        | <font color = blue>开始事务</font> |                                    |
        |        查询A账号余额为200元        |                                    |
        |        查询B账号余额为200元        |                                    |
        |        修改A账号余额为100元        |                                    |
        |        修改B账号余额为300元        |                                    |
        |        新增1条B账号入款记录        | <font color = blue>开始事务</font> |
        |                ...                 |       查询B账号入款记录为1条       |
        | <font color = red>回滚事务</font>  |                ...                 |
        |         删除B账号入款记录          |                ...                 |
        |        恢复B账号余额为200元        |                ...                 |
        |        恢复A账号余额为200元        |                ...                 |
        |                                    |                ...                 |
        |                                    |       查询B账号入款记录为0条       |
        |                                    |                ...                 |
        |                                    | <font color = blue>提交事务</font> |

## 事务的隔离等级

对于以上提到的事务并发执行过程中可能出现的问题，其严重程序是不一样的：**丢失更新 > 脏读 > 不可重复度 > 幻读**

如果我们可以容忍一些严重程度较轻的问题，我们就能获取一些性能上的提升。于是便有了事务的四种隔离级别：

-   读未提交（Read Uncommitted）
-   读已提交（Read Committed）
-   可重复读（Repeatable Read）
-   可串行化（Serializable）

|     隔离等级     | 脏读 | 不可重复度 | 幻读 |
| :--------------: | :--: | :--------: | :--: |
| Read Uncommitted |  √   |     √      |  √   |
|  Read Committed  |  ×   |     √      |  √   |
| Repeatable Read  |  ×   |     ×      |  √   |
|   Serializable   |  ×   |     ×      |  ×   |

值得注意的是以上四种隔离级别都不会出现回滚覆盖的问题，但是对MySQL来说提交覆盖的问题在RU、RC、RR这三种隔离等级下依然会发生（标准的RR隔离等级不允许出现提交覆盖问题），需要额外加锁才能避免。

## 隔离等级的实现

SQL规范定义了上述四种隔离等级，但没有规定要如何实现，因此不同数据库的实现方式和使用方式也并不相同。相较于传统的基于锁的实现方式（LBCC），MySQL采用MVCC来实现“读-写”并发控制，采用两阶段锁来实现“写-写”并发控制。

### 传统实现方式：LBCC

#### 锁的思想

-   乐观锁
-   悲观锁

#### 锁的粒度

-   行锁：只锁住某一条记录，其他的记录不受影响
-   表锁：锁住整张表，所有对该表的操作都会受影响

#### 锁的分类

-   共享锁|S锁|读锁
    1.  事务获取到S锁后允许进行读操作，不允许进行写操作；
    2.  事务获取到S锁后允许其他事务继续获取S锁；
-   排他锁|X锁|写锁
    1.  事务获取到X锁后允许进行读、写操作；
    2.  事务获取到X锁后不允许其他事务继续获取S锁、X锁

锁的相容性矩阵：

|      |  S   |  X   |
| :--: | :--: | :--: |
|  S   |  OK  | 阻塞 |
|  X   | 阻塞 | 阻塞 |

如果事务需要读取某记录应该先获得该记录的S锁，如果事务还希望阻止其他事务访问该记录则应该获得该记录的X锁。以MySQL为例，有以下两种锁定读的方式：

-   读取时对记录加S锁：

    ```mysql
    SELECT ... LOCK IN SHARE MODE; -- 对记录加S锁，直到事务结束
    ```

-   读取时对记录加X锁：

    ```mysql
    SELECT ... FOR UPDATE; -- 对记录加X锁，直到事务结束
    ```

#### LBCC实现原理

在基于锁的条件下，四种隔离级别的实现差异就在于加锁方式的不同：

-   **读未提交：写加写锁（长锁），读不加锁**

    X锁可以阻塞其他所有锁，但是如果读操作不需要获取任何锁，读操作就可以无所顾忌的读取表中的任何数据，包括其他事务未提交的脏数据

-   **读已提交：写加写锁（长锁），读加读锁（短锁）**

    X锁可以阻塞S锁，因此对读操作加S锁可以确保只能读取到事务已经提交的事务

-   **可重复读：写加写锁（长锁），读加读锁（长锁）**

    S锁可以阻塞X锁，因此对读操作接S锁可以确保其他事务不能对该数据进行修改，即在S锁释放前数据不会被修改

-   **可串行化：写加写锁（长锁），读加写锁（长锁）**

一些需要注意的细节：

1.  如果锁获取后<u>直到事务提交才释放</u>，这种锁叫**长锁**；如果锁获取后<u>用完马上就释放</u>，这种锁叫**短锁**。
2.  在可重复读和可串行化隔离级别下，读锁和写锁都是上锁，即事务提交时才释放。这种把获取锁和释放锁分为两个不同阶段的情况符合**两段锁协议**。

### MySQL实现方式：MVCC

#### 版本链

对于使用InnoDB存储引擎的表，其聚簇索引记录中包含了两个重要的<mark>隐藏列</mark>：

-   DB_TRX_ID（事务ID）：每当事务对聚簇索引中的记录进行修改时，都会把当前事务的事务id记录到DB_TRX_ID中。
-   DB_ROLL_PTR（回滚指针）：每当事务对聚簇索引中的记录进行修改时，都会把该记录的旧版本记录到undo log中，通过DB_ROLL_PTR这个指针可以用来获取该记录旧版本的信息。

如果事务中多次对记录进行修改，则每次修改都会生成undo log，并且这些undo log通过DB_ROLL_PTR指针串联成一个版本链，版本链的头结点是该记录最新的值，尾结点是事务开始时的初始值。

例如，我们在表book中做以下修改：

```mysql
BEGIN;
UPDATE book SET stock = 200 WHERE id = 1;
UPDATE book SET stock = 300 WHERE id = 1;
```

那么id = 1的记录此时的版本链就如下图所示：

<img src="markdown/MySQL - InnoDB - MVCC 多版本并发控制.assets/image-20210722144902371.png" alt="image-20210722144902371" style="zoom: 50%;" />

#### ReadView

对于Read Uncommitted隔离级别的事务来说，由于允许读取未提交事务修改过的数据，所以直接读取版本链头节点的数据即可；对于Serializable隔离等级的事务来说，InnoDB使用加锁的方式来访问记录。<mark>对于Read Committed和Repeatable Read隔离等级的事务来说，事务只能读取其他已提交事务修改过的数据，也就是说不能直接读取版本链头节点的数据，需要在版本链中找到允许被当前事务读取的数据，于是ReadView的概念就被提出用于解决这个问题。</mark>

ReadView中包含4个比较重要的内容:

-   m_ids：生成ReadView时系统中活跃的读写事务的ID组成的列表

-   min_trx_id：m_ids中的最小值

-   max_trx_id：生成ReadView时系统应该分配给下一个事务的ID值

    >   小贴士：  注意max_trx_id并不是m_ids中的最大值，事务id是递增分配的。比方说现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，m_ids就包括1和2，min_trx_id的值就是1，max_trx_id的值就是4。

-   creator_trx_id：生成ReadView的事务的ID

    >   小贴士： 只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值为0。



有了ReadView再借助**可见性比较算法**就可以在版本链中找到事务允许访问的记录版本：

1.  如果被访问版本的`db_trx_id`属性值与`ReadView`中的`creator_trx_id`值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。
2.  如果被访问版本的`db_trx_id`属性值小于`ReadView`中的`min_trx_id`值，表明生成该版本的事务在当前事务生成`ReadView`前已经提交，所以该版本可以被当前事务访问。
3.  如果被访问版本的`db_trx_id`属性值大于或等于`ReadView`中的`max_trx_id`值，表明生成该版本的事务在当前事务生成`ReadView`后才开启，所以该版本不可以被当前事务访问。
4.  如果被访问版本的`db_trx_id`属性值在`ReadView`的`min_trx_id`和`max_trx_id`之间，那就需要判断一下`db_trx_id`属性值是不是在`m_ids`列表中，如果在，说明创建`ReadView`时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建`ReadView`时生成该版本的事务已经被提交，该版本可以被访问。

如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。



<mark>在MySQL中，Read Committed和Repeatable Read隔离级别的的一个非常大的区别就是它们生成ReadView的时机不同:</mark>

-   Read Committed：每次读取记录都生成ReadView
-   Repeatable Read：首次读取记录时生成ReadView



##### 快照读、当前读

在Read Committed和Repeatable Read隔离等级下普通的`SELECT`查询都是读取版本链中的一个版本，相当于读取一个快照，因此这种读取被称为**快照读**，由于这种方式不加锁，不会产生阻塞，所以也称**非阻塞读**。

在标准的Repeatable Read隔离级别下读操作会加S锁，直到事务结束，因此可以阻止其他事务的写操作；但在MySQL的Repeatable Read隔离级别下读操作没有加锁，不会阻止其他事务对相同记录的写操作，因此在后续进行写操作时就有可能写入基于版本链中的旧数据计算得到的结果，这就导致了提交覆盖的问题。想要避免此问题，就需要另外加锁来实现。

上文提到MySQL的查询有两种加锁方式：

```mysql
SELECT ... LOCK IN SHARE MODE; -- 对记录加S锁，直到事务结束
SELECT ... FOR UPDATE; -- 对记录加X锁，直到事务结束
```

这种读取方式读取的是记录的当前最新版本，因此称为**当前读**。另外对于`INSERT`、`DELETE`、`UPDATE`操作，也是需要先读取记录，获取记录的X锁，这个过程也是一个当前读。由于需要对记录进行加锁，会阻塞其他事务的写操作，因此也称**加锁读**或**阻塞读**。当前读不仅会对读取的记录加行锁，还会对查询范围加间隙锁，因此可以防止**幻读**问题。

#### MVCC实现原理

版本链 + ReadView + MVCC

对于InnoDB来说，MVCC只在Read Committed和Repeatable Read隔离等级下的“读-写”并发场景使用。

