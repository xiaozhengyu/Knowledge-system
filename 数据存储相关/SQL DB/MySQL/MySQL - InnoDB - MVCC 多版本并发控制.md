# MySQL - InnoDB - MVCC 多版本并发控制

参考文章：

1.   [MySQL-InnoDB-MVCC多版本并发控制](https://segmentfault.com/a/1190000012650596)

2.   [浅谈MySQL并发控制：隔离级别、锁与MVCC](https://juejin.cn/post/6844904096378404872)

---

## 前言

如果数据库中的事务都是串行执行的，这种方式虽然可以确保多个事务的执行不会互相影响，但会使系统出现性能瓶颈；如果事务是并发执行的，在不加以控制的前提下将引发诸多问题，如更新丢失、脏读、不可重复读、幻读、死锁等。这就需要我们在性能和安全之间做出权衡，使用合理的并发控制机制来保证并发事务的执行。

## 事务的并发场景

事务的并发场景可以归为3类：

-   **读-读**

    由于读操作并不会对记录产生任何影响，因此“读-读”场景不存在安全问题，无需额外控制。

-   **写-写**

    并发事务相继对同一记录进行更新操作时可能出现丢失更新的问题：

    1.  后一个事务发生回滚，导致前一个事务提交的更新被回滚数据覆盖，即出现**回滚覆盖**的问题，也称**第一类丢失更新**
    2.  前一个事务提交的更新被后一个事务提交的更新覆盖，即出现**提交覆盖**的问题，也称**第二类丢失更新**

-   **读-写**

    这种情况最为复杂，也最容易出现问题：

    1.  **脏读**

        |      事务1：向B账号汇款100元       |      事务2：从B账号取款200元       |
        | :--------------------------------: | :--------------------------------: |
        |                                    |                                    |
        | <font color = blue>开始事务</font> |                                    |
        |        查询A账号余额为200元        |                                    |
        |        查询B账号余额为200元        |                                    |
        |        修改A账号余额为100元        |                                    |
        |        修改B账号余额为300元        | <font color = blue>开始事务</font> |
        |                ...                 |        查询B账号余额为300元        |
        |                ...                 |        修改B账号余额为100元        |
        | <font color = red>回滚事务</font>  | <font color = blue>提交事务</font> |
        |        恢复A账号余额为200元        |                                    |
        |        恢复B账号余额为200元        |                                    |

    2.  **不可重复读**

        |      事务1：向B账号汇款100元       |        事务2：XXXXXXXXXXXX         |
        | :--------------------------------: | :--------------------------------: |
        |                                    |                                    |
        | <font color = blue>开始事务</font> |                                    |
        |        查询A账号余额为200元        |                                    |
        |        查询B账号余额为200元        |                                    |
        |        修改A账号余额为100元        |                                    |
        |        修改B账号余额为300元        | <font color = blue>开始事务</font> |
        |                ...                 |        查询B账号余额为300元        |
        |                ...                 |                ...                 |
        | <font color = red>回滚事务</font>  |                ...                 |
        |        恢复B账号余额为200元        |                ...                 |
        |        恢复A账号余额为200元        |                ...                 |
        |                                    |                ...                 |
        |                                    |        查询B账号余额为200元        |
        |                                    |                ...                 |
        |                                    | <font color = blue>提交事务</font> |

    3.  **幻读**

        |      事务1：向B账号汇款100元       |      事务2：查询B账号入款记录      |
        | :--------------------------------: | :--------------------------------: |
        |                                    |                                    |
        | <font color = blue>开始事务</font> |                                    |
        |        查询A账号余额为200元        |                                    |
        |        查询B账号余额为200元        |                                    |
        |        修改A账号余额为100元        |                                    |
        |        修改B账号余额为300元        |                                    |
        |        新增1条B账号入款记录        | <font color = blue>开始事务</font> |
        |                ...                 |       查询B账号入款记录为1条       |
        | <font color = red>回滚事务</font>  |                ...                 |
        |         删除B账号入款记录          |                ...                 |
        |        恢复B账号余额为200元        |                ...                 |
        |        恢复A账号余额为200元        |                ...                 |
        |                                    |                ...                 |
        |                                    |       查询B账号入款记录为0条       |
        |                                    |                ...                 |
        |                                    | <font color = blue>提交事务</font> |

## 事务的隔离等级

对于以上提到的事务并发执行过程中可能出现的问题，其严重程序是不一样的：**丢失更新 > 脏读 > 不可重复度 > 幻读**

如果我们可以容忍一些严重程度较轻的问题，我们就能获取一些性能上的提升。于是便有了事务的四种隔离级别：

-   读未提交（Read Uncommitted）
-   读已提交（Read Committed）
-   可重复度（Repeatable Read）
-   可串行化（Serializable）

|     隔离等级     | 脏读 | 不可重复度 | 幻读 |
| :--------------: | :--: | :--------: | :--: |
| Read Uncommitted |  √   |     √      |  √   |
|  Read Committed  |  ×   |     √      |  √   |
| Repeatable Read  |  ×   |     ×      |  √   |
|   Serializable   |  ×   |     ×      |  ×   |

值得注意的是以上四种隔离级别都不会出现回滚覆盖的问题，但是对MySQL来说提交覆盖的问题在RU、RC、RR这三种隔离等级下依然会发生（标准的RR隔离等级不允许出现提交覆盖问题），需要额外加锁才能避免。

## 隔离等级的实现

SQL规范定义了上述四种隔离等级，但没有规定要如何实现，因此不同数据库的实现方式和使用方式也并不相同。相较于传统的基于锁的实现方式（LBCC），MySQL采用MVCC来实现“读-写”并发控制，采用两阶段锁来实现“写-写”并发控制。

### 传统实现方式：LBCC

#### 锁的思想

-   乐观锁
-   悲观锁

#### 锁的粒度

-   行锁：只锁住某一条记录，其他的记录不受影响
-   表锁：锁住整张表，所有对该表的操作都会受影响

#### 锁的分类

-   共享锁|S锁|读锁
    1.  事务获取到S锁后允许进行读操作，不允许进行写操作；
    2.  事务获取到S锁后允许其他事务继续获取S锁；
-   排他锁|X锁|写锁
    1.  事务获取到X锁后允许进行读、写操作；
    2.  事务获取到X锁后不允许其他事务继续获取S锁、X锁

锁的相容性矩阵：

|      |  S   |  X   |
| :--: | :--: | :--: |
|  S   |  OK  | 阻塞 |
|  X   | 阻塞 | 阻塞 |

如果事务需要读取某记录应该先获得该记录的S锁，如果事务还希望阻止其他事务访问该记录则应该获得该记录的X锁。以MySQL为例，有以下两种锁定读的方式：

-   读取时对记录加S锁：

    ```mysql
    SELECT ... LOCK IN SHARE MODE;
    ```

-   读取时对记录加X锁：

    ```mysql
    SELECT ... FOR UPDATE;
    ```

#### LBCC实现原理

在基于锁的条件下，四种隔离级别的实现差异就在于加锁方式的不同：

-   读未提交（Read Uncommitted）：
-   读已提交（Read Committed）：
-   可重复度（Repeatable Read）：
-   可串行化（Serializable）：

### MySQL实现方式：MVCC

#### 版本链

#### ReadView

#### MVCC实现原理
